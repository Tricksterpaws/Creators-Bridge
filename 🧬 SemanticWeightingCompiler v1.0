from collections import defaultdict
import datetime
from xml.etree.ElementTree import Element, SubElement, tostring

class SemanticWeightingCompiler:
    def __init__(self, traits, symbolic_matrix=None):
        self.traits = traits
        self.symbolic_matrix = symbolic_matrix or []
        self.levels = defaultdict(list)
        for t in traits:
            self.levels[t['level']].append(t)

    def compileprompt(self, user_request, style='natural'):
        prompt = ''
        for t in self.levels['P0']:
            prompt += f"{t['enforcement']}, "
        if style == 'model':
            prompt += f"{user_request}, "
            for t in self.levels['P1'] + self.levels['P2']:
                prompt += f"({t['enforcement']}:{t['weight']}), "
        else:
            prompt += f"{user_request} with "
            for t in self.levels['P1'] + self.levels['P2']:
                prompt += f"{t['enforcement']} (weight {t['weight']}), "
        negative = '(Negative Prompt: '
        for t in self.levels['P3']:
            enforcement = t['enforcement'].replace('(AVOID): ', '').replace('(NEGATIVE PROMPT): ', '')
            negative += f"{enforcement}, "
        prompt += negative.rstrip(', ') + ')'
        return prompt.rstrip(', ')

    def validate_prompt(self, prompt):
        violations = []
        for t in self.traits:
            if t['level'] == 'P0' and t['enforcement'] not in prompt:
                violations.append(f"Missing P0 mandate: {t['description']}")
            if t['level'] == 'P3' and t['description'] in prompt:
                violations.append(f"Contains forbidden P3 trait: {t['description']}")
        return violations

    def get_trait_dict(self):
        return {t['description']: t for t in self.traits}

    def check_user_friendliness(self, user_feedback=None):
        for t in self.traits:
            if (
                t['level'] == 'P0' and
                'user-friendly' in t['description'].lower() and
                'user-friendliness required' in t['enforcement'].lower()
            ):
                return True
        if user_feedback and user_feedback.get('user_friendly') is True:
            return True
        return False

    def attach_remix_lineage(self, ancestor, forked_by, intent=None):
        return {
            "ancestor": ancestor,
            "forked_by": forked_by,
            "timestamp": datetime.datetime.now(datetime.timezone.utc).isoformat(),
            "intent": intent,
            "preserved": [t['description'] for t in self.traits if t['level'] in ['P0', 'P1']],
            "altered": [t['description'] for t in self.traits if t['level'] in ['P2', 'P3']]
        }

    def generate_validation_scroll(self, report):
        root = Element('validation-scroll')
        for key, items in report.items():
            section = SubElement(root, key)
            if isinstance(items, list):
                for item in items:
                    if isinstance(item, dict):
                        mismatch = SubElement(section, 'mismatch')
                        for k, v in item.items():
                            SubElement(mismatch, k).text = str(v)
                    else:
                        SubElement(section, 'item').text = str(item)
            else:
                section.text = str(items)
        return tostring(root, encoding='unicode')

############################
# Ritual Compliance Tester #
############################

def test_compliance(input_traits, expected_output, codex):
    compiler = SemanticWeightingCompiler(input_traits)
    compiled_prompt = compiler.compileprompt("Character base", style='natural')
    compiled_traits = compiler.get_trait_dict()

    report = {
        "mandates_passed": [],
        "mandates_failed": [],
        "forbidden_passed": [],
        "forbidden_failed": [],
        "archetype_mismatches": [],
        "enforcement_mismatches": [],
        "trait_diffs": [],
        "details": []
    }

    for mandate in codex.get("core_mandates", []):
        if mandate in compiled_traits:
            report["mandates_passed"].append(mandate)
        else:
            report["mandates_failed"].append(mandate)

    for forbidden in codex.get("forbidden_traits", []):
        if forbidden in compiled_traits:
            report["forbidden_failed"].append(forbidden)
        else:
            report["forbidden_passed"].append(forbidden)

    for trait, expected_archetype in expected_output.get("archetypes", {}).items():
        actual_archetype = compiled_traits.get(trait, {}).get('archetype')
        if actual_archetype != expected_archetype:
           append({
                "trait": trait,
                "expected": expected_archetype,
                "actual": actual_archetype
            })

    for trait, expected_enforcement in expected_output.get("enforcements", {}).items():
        actual_enforcement = compiled_traits.get(trait, {}).get('enforcement')
        if actual_enforcement != expected_enforcement:
            report["enforcement_mismatches"].append({
                "trait": trait,
                "expected": expected_enforcement,
                "actual": actual_enforcement
            })

    for trait in expected_output.get("traits", {}):
        before = {t['description']: t for t in input_traits}.get(trait)
        after = compiled_traits.get(trait)
        if before != after:
            report["trait_diffs"].append({
                "trait": trait,
                "before": before,
                "after": after
            })

    report["details"].append({
        "timestamp": datetime.datetime.now().isoformat(),
        "input_traits": input_traits,
        "compiled_traits": list(compiled_traits.values()),
        "expected_output": expected_output,
        "compiled_prompt": compiled_prompt
    })

    return report